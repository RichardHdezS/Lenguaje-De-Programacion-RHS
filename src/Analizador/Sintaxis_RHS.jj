options {
  IGNORE_CASE = true; //para no hacer distinción entre mayúsculas y minúsculas.
  STATIC = false; //para que los métodos que genere la compilación no sean estáticos.
}

/**************************** Mi primer lenguaje de programacion  ***********************+**/
PARSER_BEGIN(Sintaxis_RHS)

package Analizador; 
public class Sintaxis_RHS {
}

PARSER_END(Sintaxis_RHS)

/** Comenzamos a definir los tokens de mi lenguaje**/

TOKEN:
{
	  <ASIGNACION : "=">  
	| <MAS : "+" >  
	| <MENOS:"-"> 
	| <MULTI:"*"> 
	| <DIV:"/"> 
	| <INCR: "++" > 
	| <DECR: "--" >
	| <EVALUAR: "EvaluarExprecion">
}

TOKEN:
{
	  <PUBLICO: "public"> 
	| <PRIVADO: "private"> 
	| <ESTATICO: "static"> 
	| <VOID: "void"> 
	| <MAIN: "StartMain()"> 
	| <PROGRAMA: "BEGIN" >  
}

TOKEN:
{
	  <IF: "_if" > 
	| <ELSE:"_else" > 
	| <ELSEIF:"_ifElse" > 
	| <FOR:"_for" > 
	| <SWITCH:"_SW" > 
	| <CASE:"case_SW" > 
	| <BREAK:"Case_break" > 
	| <DEFAUL:"Defl" > 
	| <DO:"_do" > 
	| <WHILE:"_while" > 
	| <WRITE:"_escribe_" > 
	| <READ:"_leer_" > 
}

TOKEN:
{
      <PARENI: "(" > 
	| <PAREND: ")" > 
	| <LLAVEI: "{" > 
	| <LLAVED: "}" > 
	| <BRACKETI: "[" > 
	| <BRACKETD: "]" > 
	| <PUNTCOM: ";" > 
	| <COMMA: "," > 
	| <PUNTO: "." > 
	| <DOUBLECOMMA: "\""> 
}

TOKEN:
{
	  <IGUAL: "==" > 
	| <MENQ: "<=" > 
	| <MEN: "<" > 
	| <MAYQ: ">=" > 
	| <MAY: ">" > 
	| <DIF: "!=" > 
    | <BAN: "!" > 
	| <OR: "||" > 
	| <AND: "&&"> 
    | <TRUE: "true">       
	| <FALSE: "false">
}

TOKEN:
{
	  <INT:"Int"> //44
	| <DEC: "Dec"> //45
	| <CHR: "Chr"> //46
	| <STR: "Str"> //47
    | <BOOL: "Bool"> //48
	| <NUMERO : (["0"-"9"])+>  //49
	| <IDENTIDICADOR : ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_"])*>  //50
	| <DECIMAL : (["0"-"9"])+["."](["0"-"9"])+ > //51
	| <CADENA : <DOUBLECOMMA>["a"-"z","A"-"Z","0"-"9"," "](["a"-"z","A"-"Z","0"-"9"," ",":",";","."])*<DOUBLECOMMA>> //52
	| <CARAC : "'"["a"-"z","A"-"Z","0"-"9"]"'" >//53
	| <DOUBLEPOINT : ":"> //54
}

SKIP : 
{ 
	" "|"\n" | "\r" | "\r\n" | "\t"
}

/** Comeizo a definir la sintaxis de mi lenguaje de programacion*/

void EjecutarLP():
{}
{
	<PROGRAMA><IDENTIDICADOR><LLAVEI>Bloque()<LLAVED><EOF>
	
}

void Bloque():
{}
{
	LOOKAHEAD(2)VariablesGlobales() | CuerpoPrincipal()
}

void VariablesGlobales():
{}
{
	(<PUBLICO>|<PRIVADO>) (DeclararInt()| DeclararDec()| DeclararBol()|DeclararChar()|DeclararStr()) Bloque()
}

void DeclararInt():
{}
	{
		<INT><IDENTIDICADOR><ASIGNACION><NUMERO>(<COMMA><IDENTIDICADOR><ASIGNACION><NUMERO>)*<PUNTCOM>
	}

void DeclararDec():
{}
	{
		<DEC><IDENTIDICADOR><ASIGNACION><NUMERO>(<COMMA><IDENTIDICADOR><ASIGNACION><NUMERO>)*<PUNTCOM>
	}

void DeclararStr():
{}
	{
		<STR><IDENTIDICADOR><ASIGNACION><CADENA>(<COMMA><IDENTIDICADOR><ASIGNACION><CADENA>)*<PUNTCOM>
	}

void DeclararChar():
{}
	{
		<CHR><IDENTIDICADOR><ASIGNACION><CARAC>(<COMMA><IDENTIDICADOR><ASIGNACION><CARAC>)*<PUNTCOM>
	}
	
void DeclararBol():
{}
	{
		<BOOL><IDENTIDICADOR><ASIGNACION>(<TRUE>|<FALSE>)(<COMMA><IDENTIDICADOR><ASIGNACION>(<TRUE>|<FALSE>))*<PUNTCOM>
	}
	
void CuerpoPrincipal():
{}
{
	<MAIN><LLAVEI>Sentencias()<LLAVED>
}

void VariablesLocales():
{}
{
	(DeclararInt()| DeclararDec()| DeclararBol()|DeclararChar()|DeclararStr()) VS()
}

void Sentencias():
{}
{
	(	
	  VariablesLocales()
    | SentenciaIf()
	| SentenciaFor()
	| SentenciaWhile()
	| SentenciaDo()
	| SentenciaSwitch()
	| Evaluar()
	)*
}

void VS():
{}
{
	LOOKAHEAD(3)VariablesLocales() | Sentencias()
}

void SentenciaIf():
{}
{
	<IF><PARENI>ValidaBool()<PAREND><LLAVEI>Sentencias()<LLAVED> (SentenciaIfElse() | Sino())+ 
}

void ValidaBool():
{}
	{
	(<IDENTIDICADOR>|<NUMERO>|<DECIMAL>)(<MEN>|<MAY>|<IGUAL>|<MENQ>|<MAYQ>|<DIF>|<AND>|<OR>|<BAN>)(<IDENTIDICADOR>|<NUMERO>|<DECIMAL>)((<AND>|<OR>)((<IDENTIDICADOR>|<NUMERO>|<DECIMAL>)(<MEN>|<MAY>|<IGUAL>|<MENQ>|<MAYQ>|<DIF>|<AND>|<OR>|<BAN>)(<IDENTIDICADOR>|<NUMERO>|<DECIMAL>)))*
	}

void SentenciaIfElse():
{}
{
	<ELSEIF><PARENI>ValidaBool()<PAREND><LLAVEI>Sentencias()<LLAVED> (SentenciaIfElse() | Sino())+ 
}

void Sino():
{}
{
	<ELSE><LLAVEI>Sentencias()<LLAVED>
}

void SentenciaFor():
{}
{
	<FOR><PARENI>((<INT>)?<IDENTIDICADOR><ASIGNACION><NUMERO><PUNTCOM>ValidaBool()<PUNTCOM>(<IDENTIDICADOR>(<INCR>|<DECR>))?)<PAREND><LLAVEI>Sentencias()<LLAVED>
}

void SentenciaWhile():
{}
{
	<WHILE>
        <PARENI>ValidaBool()<PAREND><LLAVEI>Sentencias()<LLAVED>
}

void SentenciaDo():
{}
{
	<DO><LLAVEI>Sentencias()<LLAVED><WHILE><PARENI>ValidaBool()<PAREND><PUNTCOM>
}

void SentenciaSwitch():
{}
{
	<SWITCH>
	<PARENI>
	<IDENTIDICADOR>
	<PAREND>
	<LLAVEI>
	(<CASE><IDENTIDICADOR><DOUBLEPOINT>
	Sentencias()
	<BREAK><PUNTCOM>)+
	<DEFAUL><DOUBLEPOINT>
	Sentencias()
	<BREAK><PUNTCOM>
	<LLAVED>
}

/****Seccion para evaluar las expreciones aritmeticas*******/

void Evaluar():
{}
{
	(EvaluarOperacionesArit())+
}

void EvaluarOperacionesArit():
{double e;}
{
	<EVALUAR> <BRACKETI> e=Expresion() <BRACKETD> <PUNTCOM> {System.out.println("El valor de la expresion es: "+e);}
}

/** Expresion -> ExpresionMultiplicativa ('+' ExpresionMultiplicativa)*
              |  ExpresionMultiplicativa ('-' ExpresionMultiplicativa)*
*/
double Expresion() :
{double e, e1;}
{
    e=ExpresionMultiplicativa()
    (
        <MAS> e1=ExpresionMultiplicativa() {e += e1;}
        |
        <MENOS> e1=ExpresionMultiplicativa() {e -= e1;}
    )*
    {return e;}
}

/** ExpresionMultiplicativa -> ExpresionUnaria ('*' ExpresionUnaria)*
                            |  ExpresionUnaria ('/' ExpresionUnaria)*
*/
double ExpresionMultiplicativa() :
{double e, e1;}
{
    e=ExpresionUnaria()
    (
        <MULTI> e1=ExpresionUnaria() {e *= e1;}
        |
        <DIV> e1=ExpresionUnaria() {e /= e1;}
    )*
    {return e;}
}

/** ExpresionUnaria -> '-' ExpresionUnaria
                    |  Primitivo
 */
double ExpresionUnaria() :
{double e;}
{
    <MENOS> e=ExpresionUnaria() {return -e;}
    |
    e=Primitivo() {return e;}
}

/** Primitivo -> Numero
              |  Decimal
              |  '(' Expresion ')' 
*/
double Primitivo() :
{double e;}
{
    <NUMERO> {return Double.parseDouble(token.image);}
    |
    <DECIMAL> {return Double.parseDouble(token.image);}
    |
    <PARENI> e=Expresion() <PAREND> {return e;}
}






